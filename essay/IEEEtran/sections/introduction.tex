\section{Introduction}
Over the last few years software has become increasingly complex. It is so much complex that is almost impossible to see how it can be abused. The problem is even worst when one is forced to trust other people's code. Many secure languages have been developed from scratch for solving this kinds of problems. Two well-known examples are Jif \cite{pullicino2014jif} by \citeauthor{pullicino2014jif} and Flowcaml \cite{simonet2003flow} by \citeauthor{simonet2003flow}. The former is a Java extension which adds support for security labels such that the developers can specify confidentiality and integrity policies to the various variables used in their program. The letter, instead, is an extension of the Objective Caml language with a type system tracing information flow. Its purpose is basically to allow to write real programs and to automatically check that they obey some security policy. \\
However, it is a very heavy-weight solution to introduce a new programming language. In fact, despite of the large work on that, there has been relatively little adoption of the proposed techniques. Moreover, often only a small part of the system (maybe only a few variables in a large program) has security requirements. This is why many researchers have developed new lightweight libraries for ensuring security properties while programming. This paper aims to go further this direction. \\
Here I present a Haskell based library which ensures some security properties and a real-world use case for that. This library might be used in scenarios where we want to incorporate in our programs some code written by outsiders (untrusted programmers) to access our private information. We would like to have a guarantee the program will not send our private data to an attacker. A slightly different, but related, scenario is where we ourselves write the possible unsafe code, but we want to have the help of the type checker to find possible security mistakes. \\
\citeauthor{li2006encoding} \cite{li2006encoding} have previously explored the possibility to ensure information flow security as a library, but their approach is \textit{arrow} based (\cite{hughes2000generalising}). Hence, programmers have to be familiar with arrows. Afterwards, \citeauthor{russo2008library} \cite{russo2008library} have shown that a monadic solution is also possible. Unfortunately, their work makes an intense use of the \texttt{IO} monad, thus their system is non-completely static. \\
In this paper I lightly build the last mentioned library up and formalise two new types. As a result, the following security properties are met by my work: secure information flow, augmented with \textit{declassification policies}, secure computation on untainted data and dynamic validation of user input before their use. \\
The remainder of this paper is organized as follows. Section~\ref{sec:assumptions} formalises my assumptions. Section~\ref{sec:example} describes the motivating example. Sections~\ref{sec:flow}, \ref{sec:computation} and \ref{sec:unsecure} provide descriptions and implementation details about the three secure types: \texttt{Unsecure}, \texttt{SecureFlow} and \texttt{SecureComputation}. Section~\ref{sec:limitations} sums my contribute up and emphasises its limitations. My discussion is then concluded in Section~\ref{sec:conclusion}.