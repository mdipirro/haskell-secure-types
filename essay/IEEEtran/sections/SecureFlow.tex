\section{The SecureFlow module}\label{sec:flow}
Software usually manipulates information with different security policies. For instance, passwords are sensitive data, while names or birth dates are not. During execution sometimes we want to be sure sensitive information don't flow to insecure or public output channels. On the other hand, usually we perform some operations on these reserved data. After a successful login the user is sure the provided password is correct. \\
The goal with \texttt{SecureFlow} is to ensure information flow security and declassification policies at compile-time, so that if a code is correctly compiled there are no certain security violations. \\
\citeauthor{russo2008library} \cite{russo2008library} have developed a monadic approach, but their intensive use of the \texttt{IO} monad makes their solution not fully static.

\subsection{Security lattice}
\texttt{SecureFlow} is based on a lattice structure, first introduced by \citeauthor{denning1976lattice} \cite{denning1976lattice}, and represented in this library as a type family \cite{kiselyov2010fun}. Security levels are associated to data in order to establish its degree of confidentiality. The ordering relation in the lattice, written $\sqsubseteq$, represents allowed flows. For instance, $l_{1} \sqsubseteq l_{2}$ indicates that information at security level $l_{1}$ may flow into entities of security level $l_{2}$. In this paper the lattice is implemented like a ticketing system. Listing~\ref{lst:lattice} shows the \texttt{Lattice} module. 
\begin{lstlisting}[caption={The Lattice module}, label={lst:lattice}, breaklines=true]
module Security.Lattice (LEQ, Ticket(Ticket)) where

type family LEQ sl sh :: Constraint
data Ticket s = Ticket
\end{lstlisting}
Basically, \texttt{LEQ}, as a type family, represents a partial function at the type level. Applying the function to parameters (called \textit{type indices}) yields a type. Type families permit a program to compute what data constructors it will operate on, rather than having them fixed statically. Here, LEQ means \textit{Less or Equal}. Trusted programmers are asked to instantiate it specifying the real security lattice. A three level lattice example is shown in Listing~\ref{lst:3lvs}.
\begin{lstlisting}[caption={Three levels lattice}, label={lst:3lvs}, breaklines=true]
module ThreeLevels (Low, Medium, High, low, medium) where

data Low    = L
data Medium = M
data High   = H

type instance (LEQ Low Low)       = ()
type instance (LEQ Low Medium)    = ()
type instance (LEQ Low High)      = ()
type instance (LEQ Medium Medium) = ()
type instance (LEQ Medium High)   = ()
type instance (LEQ High High)     = ()

low :: Ticket Low
low = Ticket

medium :: Ticket Medium
medium = Ticket

high :: Ticket High
high = Ticket
\end{lstlisting}
Here, \texttt{Low}, \texttt{Medium} and \texttt{High} are singleton types (\cite{stone2000singleton}, \cite{pierce2005advanced}). Basically, singleton types are those which have only one value. Thus, the value of a singleton type has a unique type representing the value. A type theory that allows types to be parameterised by values (like the one adopted by Haskell) can use singleton types to let types depend on singleton values. The sequence of \texttt{type instance} allows programmers to specify the relations among \texttt{Low}, \texttt{Medium} and \texttt{High}. Listing~\ref{lst:3lvs} shows also a ticketing system instance. Tickets are generally used as a level proof. Note that the \texttt{high} ticket is not exported, so that one may get access to high secure data only according to the declassification policies. The ordering relation among \texttt{Low}, \texttt{Medium} and \texttt{High} is the following: $Low \sqsubseteq Medium \sqsubseteq High$.

\subsection{SecureFlow Implementation}
Basically, \texttt{SecureFlow} is just an identity monad instance tagged with a proposition allowing access to its value. Actually, that proposition is just a ticket. Listing~\ref{lst:secureflow} shows the module.
\begin{lstlisting}[caption={SecureFlow monad}, label={lst:secureflow}, breaklines=true]
data SecureFlow s a = Allowed a | Denied
type Hatch s a b = SecureFlow s (a -> Maybe b)

instance Functor (SecureFlow s) where
  fmap f (Allowed x)  = Allowed $ f x
  fmap _ Denied       = Denied

instance Applicative (SecureFlow s) where
  pure x                      = Allowed x
  (Allowed f) <*> (Allowed x) = Allowed $ f x
  _ <*> _                     = Denied

instance Monad (SecureFlow s) where
  return            = pure
  (Allowed a) >>= f = f a
  Denied >>= _      = Denied
  fail _            = Denied
  
open :: LEQ s s' => Ticket s' -> SecureFlow s a -> Maybe a

up :: LEQ s s' => SecureFlow s a -> SecureFlow s' a

declassifyWith :: (LEQ s k, LEQ s' s) => Hatch k a b -> SecureFlow s a -> SecureFlow s' b
\end{lstlisting}
%\input{sections/SecureFlow_proofs/functor}
%\input{sections/SecureFlow_proofs/applicative}
\input{sections/SecureFlow_proofs/monad}
\texttt{SecureFlow} is also a functor and an applicative. The proof is largely similar to the last one, so it is omitted. \\
The module also exports three important functions, \texttt{up}, \texttt{open} and \texttt{declassifyWith}. Their meaning is self explained by their names, but I am to describe them in detail without giving their actual implementation. \\
\texttt{open} is used to look at a protected value of type \texttt{SecureFlow s a}. However, in order to do that, one has to prove to have a value of type \texttt{s}. Restricting access to values of different such types s by means of the module system allows fine control over which parts of the program can look at what data. This proof is given with the ticketing system. Note that, if the value is protected with \texttt{SecureFlow s a}, the ticket type must be in the \texttt{LEQ} relation with \texttt{s}. This actually means the relation $s \sqsubseteq s'$ must hold. However, the compiler give a type error because of the unsatisfied type constraint \texttt{LEQ s s'}. Furthermore, \texttt{Maybe a} as returned value type is necessary since \texttt{SecureFlow} has a constructor for mistaken situations (which is \texttt{Denied}). \\
The function \texttt{up} can be used to turn any protected value into a protected value at a higher security level. A real use scenario is the following. Consider a company in which employees' salaries are calculated based on different public attributes, such as long service bonuses, experience, responsibility levels and so on. Even if those attributes are public, we want to keep secret the actual salary. In such a scenario \texttt{up} is useful because it allows us to turn the calculated value into an higher security level, such that \textit{public} tickets cannot open that. \\
Non-interference is a security policy that specifies the absence of information flows from secret to public data. So far, the provided library has followed strictly this policy. However, real-word applications release some information as part of their intended behavior. Non-interference does not provide means to distinguish between such releases of information and those ones produced by malicious code, programming errors, or vulnerability attacks. Consequently, it is needed to relax the notion of non-interference to consider declassification policies or intended ways to leak information. \\
\citeauthor{sabelfeld2005dimensions} \cite{sabelfeld2005dimensions} have recently provided a classification of those policies. Basically, each dimension represent a specific policy aspect corresponding to \textit{what}, \textit{where}, \textit{when} and by \textit{whom} data is released. Researchers have defined type systems for enforcing these aspects (\cite{banerjee2008expressive}, \cite{zdancewic2001robust}, \cite{zdancewic2003type}), but their encoding into this work would considerably increase its complexity. This is why here I provide a \textit{declassification combinator}, \texttt{declassifyWith}, which allows trusted programmers to compose and create declassification policies from scratch. Those policies are based on the \texttt{SecureFlow} monad, hence a statical type check is done on them. In this way, declassification still lie on the non-interference idea, but untrusted programmers are allowed to work with secret data without producing leaks.
%Lastly, \texttt{declassifyWith} allows us to specify declassification policies.