\section{A real-world use case}\label{sec:example}
Consider a company which would like to manage its employees data and the situation of its stores. Suppose that every operation on those data must be done after a login. In such a scenario, passwords should remain secrets, and a declassification policy should be applied during the login procedure. In fact, after a successful login, a user knows that the provided password was correct. Then, the logged user may perform some operations on the stores data. Moreover, if he or she is a company leader, he or she can increase an employee's salary. The salary is strictly confidential, so nobody may know it. \\
The following security properties must be met in this application. First, passwords and salaries are confidential and they may not be shown in a public output channel (i.e.the console). Second, a natural number (e.g. the increment amount) coming from the user must be validated before its use. Moreover, in sensitive operations, the value must be marked as pure (i.e. untainted). \\
We would be sure that two of them, secure information flow and secure computation over data, are ensured at compile time, before the execution of the application. The third, input validation, must be performed at run-time, since inputs vary from an execution to another. Thus, the type system will only be able to check that an input value is validated before a real use. I will go deeper on that in section 5. \\
The application database is composed by three JSON (\textbf{J}ava\textbf{S}cript \textbf{O}bject \textbf{N}otation) files, as follows: \texttt{credentials.json}, \texttt{employees.json} and \texttt{stores.json}, with the obvious meaning. The choice of JSON files is motivated by the simplicity in their manipulation. A SQL-based (or whatever) version would be possible too.
