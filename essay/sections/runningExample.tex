\section{A real-world use case}\label{sec:example}
Consider a company which would like to manage its employees data and the situation of its stores. Suppose that every operation on those data must be done after a login. In such a scenario, passwords should remain secret, and a declassification policy should be applied during the login procedure. In fact, after a successful login, a user can retrieve some information, such as that the provided password was correct. \\
Subsequently, the logged user may manage the stores situation. Moreover, if he or she is a company leader, he or she can increase an employee's salary. The salary is strictly confidential, so nobody may know it. \\
The following security properties must be met in this application. First, passwords and salaries are confidential and the application may not make them known. Second, a natural number (e.g. the increment amount) coming from the user must be validated before its use. In addition, in sensitive operations, the value must be marked as pure (i.e. untainted). \\
We would be sure that two of them, secure information flow and secure computation over data, are ensured at compile time, before the application execution. The third, input validation, must be performed at run-time, since input vary from an execution to another. Thus, the type system will only be able to check that an input value is validated before a real use. I shall go deeper on that in Section~\ref{sec:unsecure}. \\
The application database is composed by three JSON (\textbf{J}ava\textbf{S}cript \textbf{O}bject \textbf{N}otation) files, as follows: \texttt{credentials.json}, \texttt{employees.json} and \texttt{stores.json}, with the obvious meaning. The choice of JSON files is motivated by the simplicity in their manipulation. A SQL-based (or whatever) version would be possible too.
