\section{Limitations} \label{sec:limitations}
Every security technique has some drawbacks. In particular, with software security, the main drawback is an usability loss. Secure languages and type systems are chiefly used in critical situations, where a secure software is absolutely mandatory. Programmers in those scenarios must write secure and verified code. On the other hand, the vast majority of current software does not make the security the principal concern. Furthermore, programmers sometimes write leaky code as a consequence of an usability lack of the programming language itself. \\
This library, as defined, suffers from such usability problems. First of all, trusted programmers must override and define new input functions to include \texttt{Unsecure} and \texttt{SecureComputation} in the application code. This will be annoying if every new function requires an override. On the other hand, a fine granularity input check without those modules would imply a huge amount of code, with possible repetitions, mistakes and consistency lacks. Anyway, those modules are supposed to be used in small portions of the entire program, and in particular only for sensitive values or scenarios. Otherwise a fully secure programming language would be more suitable. Furthermore, with the current version, \texttt{Unsecure} and \texttt{SecureComputation} are not functor, applicative and monad instances. \\
Despite its complete independence from the final use, the \texttt{Hatch} combinator leaves some freedom to programmers. As a matter of fact, it is defined in terms of the encapsulated-value security tag and programmers have to specify explicitly the final level. That entails a possible attack. Consider the following \texttt{showSalary} function, first shown in Listing~\ref{lst:salary}: \\ \texttt{showSalary :: Hatch High Int Int\\showSalary = pure id} \\
\textit{High} is referred to the salary level \textit{before} the declassification, but \texttt{Hatch} specifies nothing about the level \textit{after} the declassification. This is a big leak. With a three levels lattice, for instance, one may open the declassified value with either a \texttt{low} or a \texttt{medium} ticket. Everything is left to the explicit type annotation which, based on my assumptions, might be written by an untrusted programmer! A feasible solution is a more strict, and complicated, \texttt{Hatch} version, shown in Listing~\ref{lst:newhatch} and named \texttt{Hatch'}.
\begin{lstlisting}[caption={A more strict Hatch version}, label={lst:newhatch}, breaklines=true]
type Hatch' s l a b = SecureFlow l (SecureFlow s (a -> b))

makeHatch :: (a -> b) -> Hatch' s l a b
makeHatch f = pure $ pure f

declassifyWith' :: (LEQ s k, LEQ s' s, LEQ l s') => Hatch' k l a b -> SecureFlow s a -> SecureFlow s' b
\end{lstlisting}
In this new version, \texttt{Hatch'} is defined as a double \texttt{SecureFlow} encapsulation of the declassification function. The new type parameter, \texttt{l} is required to specify a \textit{lower bound} for the final security tag. As a matter of fact, note the new type constraint in \texttt{declassifyWith'}. By the virtue of this new constraint, the relation $l \sqsubseteq s'$ must hold. Therefore I am forcing the final tag to be \textit{LEQ} than the one declared in the type signature. The new \texttt{showSalary} function will be as follows: \\
\texttt{showSalary :: Hatch' High Medium Int Int \\showSalary = makeHatch id} \\
Where \texttt{makeHatch} is just a shortcut to hide the double \texttt{SecureFlow} encapsulation. \\
With this modification, programmers still have to explicitly declare the final tag as a type annotation, but the type is constrained by the declassification policy type signature, so that it must be at least (\textit{LEQ}) the declared one. \\
Finally, in order to force the declared and the actual final tags to be the same, another type constraint ought to be added to \texttt{declassifyWith'}: \texttt{LEQ s' l}. This means the relations $l \sqsubseteq s'$ and $s' \sqsubseteq l$ must hold, which requires \textit{l} to be equal to $s'$.