\section{Introduction}
Over the last few years software has become increasingly complex. It is so much complex that is almost impossible to see how it can be abused. The problem is even worst when one is forced to trust other people's code. Many secure languages have been developed from scratch for solving this kinds of problems. Two well-known examples are Jif \cite{pullicino2014jif} by \citeauthor{pullicino2014jif} and Flowcaml \cite{simonet2003flow} by \citeauthor{simonet2003flow}. The former is a Java extension adding support for security labels such that the developers can specify confidentiality and integrity policies to the various variables used in their program. The letter, instead, is an extension of the Objective Caml language with a type system tracing information flow. Its purpose is basically to allow to write real programs and to automatically check whether they obey some security policy. \\
However, it is a very heavy-weight solution to introduce a new programming language. In fact, despite of the large work on that, there has been relatively little adoption of the proposed techniques. Moreover, often only a small part of the system (maybe only a few variables in a large program) has security requirements. This is why many researchers have developed new lightweight libraries for ensuring security properties while programming. This paper aims to go further this direction. \\
Here I present a Haskell based library ensuring some security properties and a real-world use case for them. This library might be used in scenarios where we want to incorporate in our programs some code written by outsiders (untrusted programmers) to access our private information. We would like to have a guarantee the program will not send our private data to an attacker. A slightly different, but related, scenario is where we ourselves write the possible unsafe code, but we want to have the help of the type checker to find possible security mistakes. \\
\citeauthor{li2006encoding} \cite{li2006encoding} have previously explored the possibility to ensure information flow security as a library, but their approach is \textit{arrow} based \cite{hughes2000generalising}. Hence, programmers have to be familiar with arrows. Afterwards, \citeauthor{russo2008library} \cite{russo2008library} have shown that a monadic solution is also possible. Unfortunately, their work makes an intense use of the \texttt{IO} monad, thus their system is non-completely static. \\
In this paper I lightly build the last mentioned library up and formalise two new types. As a result, the following security properties are met by my work: secure information flow, augmented with \textit{declassification policies}, secure computation on untainted data and dynamic validation of user input before their use. \\
The last two are new in the overview of the language-based security. Computation on pure data is important in very sensitive applications. Every value is such applications should come from a trusted source of input: my contribution is to ensure this requirement at compile time, with high flexibility about the real input source. Further, validation is the main reason of software vulnerabilities. With my work programmers will be forced to validate every untrusted value and took to provide two different paths in the program text. Those paths will correspond to a good situation, in which there are no errors, and to a bad situation, in which some errors occurred during the validation process. Although the actual validation is performed at run-time, the need of validation is provided at compile time, before executing the software. \\
With this three simple types on one hand I am to prove how easily some fundamental properties may be ensured. On the other hand, I supply a concrete framework usable in almost every scenario needing a fine-granularity software control. More work and types would be required for a comprehensive assurance. Here I want to explain in brevity how fruitful this way could be. My contribute consists of a proof about the usability of functional language-based security. \\
The remainder of this paper is organized as follows. Section~\ref{sec:assumptions} formalises my assumptions. Section~\ref{sec:example} describes the motivating example. Sections~\ref{sec:unsecure}, \ref{sec:flow} and \ref{sec:computation} provide descriptions and implementation details about the three secure types: \texttt{Unsecure}, \texttt{SecureFlow} and \texttt{SecureComputation}. Section~\ref{sec:limitations} sums my contribute up and emphasises its limitations. My discussion is then concluded in Section~\ref{sec:conclusion}.